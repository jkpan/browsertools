<script type="text/javascript" charset="UTF-8"> 

var subtitle = [ [''],
    
[
"不從惡人的計謀，不站罪人的道路，不坐褻慢人的座位，❤ ❤ ☂ ☂ ",
"惟喜愛耶和華的律法，晝夜思想，這人便為有福！",
"他要像一棵樹栽在溪水旁，按時候結果子，葉子也不枯乾。凡他所做的盡都順利。",
"惡人並不是這樣，乃像糠粃被風吹散。",
"因此，當審判的時候惡人必站立不住；罪人在義人的會中也是如此。",
"因為耶和華知道義人的道路；惡人的道路卻必滅亡。"
],

[
"耶和華是我的牧者，我必不致缺乏。",
"他使我躺臥在青草地上，領我在可安歇的水邊。",
"他使我的靈魂甦醒，為自己的名引導我走義路。",
"我雖然行過死蔭的幽谷，也不怕遭害，因為你與我同在；你的杖，你的竿，都安慰我。",
"在我敵人面前，你為我擺設筵席；你用油膏了我的頭，使我的福杯滿溢。",
"我一生一世必有恩惠慈愛隨著我；我且要住在耶和華的殿中，直到永遠。"
]

];                 

var side = 3;
var dots = 3;
var fsize = 102;
var FONT = fsize + "px 標楷體";//黑體-繁";//宋體-繁";
var speed = 100;

var initDot = 0;
var jumpLine = (side + dots) * fsize * 4;
var jumpSide = (side + dots) * 4;

if (dots == 3) {
  initDot = ((side + 1) * fsize + (side + 1)) * 4;//(4 * fsize + 4) * 4;
} else if (dots == 2) {
  initDot = ((side + 1) * fsize + (side + 1)) * 4;//(4 * fsize + 4) * 4;
} else if (dots == 1) {
  initDot = (side * fsize + side) * 4;//(4 * fsize + 4) * 4;
}

</script>

<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <style>
      body {
        margin: 0px;
        height: 100%;
        background-color:green;
        /*cursor:none;*/
      }
      /*
      main {
        position: fixed;
        width: 100%;
        height: 100%;
      }
      */
      ::-webkit-scrollbar {
        display: none;
      }
    </style>
    </head>   
<body>

  <canvas id="canvas" width="100" height="100"></canvas>

</body>

</html>


<script type="text/javascript" charset="UTF-8">

var canvas;
var ctx;

function init() {
    canvas = document.getElementById("canvas");
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx = canvas.getContext("2d");
}

function newParticle_txt(_p, _idx, xx, yy) {
  let p = {
    x: xx,
    y: yy,
  idx: 0,
  txt: "",
  idxlen:0,
  elapse:0,
  p: _p,
  idx: _idx,
    release: function() {
      this.txt = '';
    },

    initial: function (c) {

      this.txt = subtitle[this.p][this.idx];
    
      this.idxlen = Math.max(2, Math.floor(this.txt.length * 0.8));//10 + 10 * Math.random();
      this.elapse = 0;
      this.idx = 0;
      this.gap = 0.08 + Math.random() * 0.1;

      return this.txt.length;

    },
    update: function (c, _ctx, dt) {
        
      //console.log(this.y);

      if (dt > 1000) dt = 16;

      //this.size += 0.05 * this.size * dt * 0.001;
      this.y -= dt * 0.001 * speed;

      if (this.y < -this.txt.length * fsize)
        return;

      if (this.y > c.height + fsize)
        return;

      _ctx.textAlign = "left";
      _ctx.font = FONT;// + "px 標楷體";
      
      _ctx.strokeStyle = 'white';
      _ctx.lineWidth = 4;
        
      _ctx.fillStyle = 'white';

      for (var i = 0;i<this.txt.length;i++) {
        let _x = this.x; 
        let _y = this.y + (i * fsize);
        if (_y < -fsize) 
            continue;
        if (_y > c.height + fsize) 
            break;
    
        _ctx.strokeText(this.txt.substr(i, 1), _x, _y);
        _ctx.fillText(this.txt.substr(i, 1), _x, _y);
        //console.log(this.txt.substr(i, 1) + '('+ this.x + ', ' + (this.y + (i * fsize)) + ')');
      }

      //console.log("repaint");

    }
  }
  return p;
}

function anim_update(elapse) {

  var c = document.getElementById("canvas");
  var ctx = c.getContext("2d");

  ctx.clearRect(0, 0, c.width, c.height);

  ctx.fillStyle = 'green';
  ctx.fillRect(0, 0, c.width, c.height);

  let dt = elapse - pre;
  pre = elapse;

  if (keepGoing == 1) {
    
    if (maskimg) {
      ctx.fillStyle = 'black';
      ctx.fillRect(fsize - 4, 0, fsize + 8, c.height);
    }
    
    for (var i = 0;i<particles.length;i++) {
        particles[i].update(c, ctx, dt);
    }

    if (maskimg) {
        ctx.drawImage(maskimg, fsize, 0);

        
        let mask = ctx.getImageData(fsize, 0, fsize, c.height);
        var data = mask.data;
        let gapL = fsize * 4;
        let gapP = 4;
        let wid = fsize;
        
        for (let i = initDot;i < data.length;i += jumpLine) {
        
          let pix = i/4;
          let h = Math.floor(pix/wid);
          let w = pix%wid;
        
          for (let k = i;;k+=jumpSide) {
            let _pix = k/4;
            let _h = Math.floor(_pix/wid);
            let _w = _pix%wid;
            if (_h != h) 
              break;
            if (data[k] > 200) {
                //中
                data[k]     = 255;
                data[k + 1] = 50;
                data[k + 2] = 50;
                data[k + 3] = 255;

                if (dots == 1) continue;

                //左
                data[k - gapP]     = 255;
                data[k + 1 - gapP] = 50;
                data[k + 2 - gapP] = 50;
                data[k + 3 - gapP] = 255;
                //上
                data[k - gapL]     = 255;
                data[k + 1 - gapL] = 50;
                data[k + 2 - gapL] = 50;
                data[k + 3 - gapL] = 255;
                //左上
                data[k - gapP - gapL]     = 155;
                data[k + 1 - gapP - gapL] = 50;
                data[k + 2 - gapP - gapL] = 50;
                data[k + 3 - gapP - gapL] = 255;

                if (dots == 2) continue;

                //右
                let idx = k + gapP;
                let pp = idx/4;
                let hh = Math.floor(pp/wid);
                let ww = pp%wid;
                if (hh == _h) {
                  //右
                  data[idx]     = 255;
                  data[idx + 1] = 50;
                  data[idx + 2] = 50;
                  data[idx + 3] = 255;
                  //右上
                  data[idx - gapL]     = 155;
                  data[idx - gapL + 1] = 50;
                  data[idx - gapL + 2] = 50;
                  data[idx - gapL + 3] = 255;

                  
                  idx = k + gapP + gapL;
                  pp = idx/4;
                  hh = Math.floor(pp/wid);
                  ww = pp%wid;
                  if (idx < data.length) {
                    //右下
                    data[idx]     = 155;
                    data[idx + 1] = 50;
                    data[idx + 2] = 50;
                    data[idx + 3] = 255;

                    //下
                    data[k + gapL]     = 255;
                    data[k + 1 + gapL] = 50;
                    data[k + 2 + gapL] = 50;
                    data[k + 3 + gapL] = 255;
                    //左下
                    data[k - gapP + gapL]     = 155;
                    data[k + 1 - gapP + gapL] = 50;
                    data[k + 2 - gapP + gapL] = 50;
                    data[k + 3 - gapP + gapL] = 255;
                  }
                }
            } else {
                
                //中
                data[k]     = 0;
                data[k + 1] = 0;
                data[k + 2] = 0;
                data[k + 3] = 255;

                if (dots == 1) continue;

                //左
                data[k - gapP]     = 0;
                data[k + 1 - gapP] = 0;
                data[k + 2 - gapP] = 0;
                data[k + 3 - gapP] = 255;
                //上
                data[k - gapL]     = 0;
                data[k + 1 - gapL] = 0;
                data[k + 2 - gapL] = 0;
                data[k + 3 - gapL] = 255;
                //左上
                data[k - gapP - gapL]     = 0;
                data[k + 1 - gapP - gapL] = 0;
                data[k + 2 - gapP - gapL] = 0;
                data[k + 3 - gapP - gapL] = 255;

                if (dots == 2) continue;

                //右
                let idx = k + gapP;
                let pp = idx/4;
                let hh = Math.floor(pp/wid);
                let ww = pp%wid;
                if (hh == _h) {
                  data[idx]     = 0;
                  data[idx + 1] = 0;
                  data[idx + 2] = 0;
                  data[idx + 3] = 255;
                  //右上
                  data[idx - gapL]     = 0;
                  data[idx - gapL + 1] = 0;
                  data[idx - gapL + 2] = 0;
                  data[idx - gapL + 3] = 255;

                  
                  idx = k + gapP + gapL;
                  pp = idx/4;
                  hh = Math.floor(pp/wid);
                  ww = pp%wid;
                  if (idx < data.length) {
                    //右下
                    data[idx]     = 0;
                    data[idx + 1] = 0;
                    data[idx + 2] = 0;
                    data[idx + 3] = 255;

                    //下
                    data[k + gapL]     = 0;
                    data[k + 1 + gapL] = 0;
                    data[k + 2 + gapL] = 0;
                    data[k + 3 + gapL] = 255;
                    //左下
                    data[k - gapP + gapL]     = 0;
                    data[k + 1 - gapP + gapL] = 0;
                    data[k + 2 - gapP + gapL] = 0;
                    data[k + 3 - gapP + gapL] = 255;
                  }
                }
                
            }
          }
      }
      ctx.putImageData(mask, fsize, 0);
      
    }
    //
    
    window.requestAnimationFrame(anim_update);
  }

}

function initAnim() {

  keepGoing = 0;
  if (phase == 0) {       
      return;
  }

  var c = document.getElementById("canvas");
  var ctx = c.getContext("2d");

  //console.log(c.width + ', ' + c.height);
  
  if (particles.length >= 1) {
    for (var i = 0;i<particles.length;i++) {
      particles[i].release();
    }
  }

  particles.length = 0;
  particles = [];

  let xx = fsize;
  let yy = c.height + fsize;
  let _idx = 0;
  var total = subtitle[phase].length;//Math.min(35, 15 + 5 * Math.floor(c.width/500));//console.log('total:'+total);
  for (_idx = 0;_idx<total;_idx++) {
      particles[_idx] = newParticle_txt(phase, _idx,  xx, yy);//();
      let txtlen = particles[_idx].initial(c);
      yy += (txtlen + 2) * fsize;
  }

  keepGoing = 1;
  window.requestAnimationFrame(anim_update);
}

function doresize() {
  init();
  //initAnim();
  if (maskimg != null) {
    ledEffect();
  }
}

function generateMask(w, h, s, d) {

  var mask = ctx.createImageData(w, h);
  var data = mask.data;

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {

        let idx = (y * w + x) * 4;

        data[idx + 0] = 40;
        data[idx + 1] = 40;
        data[idx + 2] = 40;
        data[idx + 3] = 255;
        
        let _x = x%(s + d);
        let _y = y%(s + d);
        if (_x >= s && _y >= s) { //d

          data[idx + 3] = 0;
        }

    }
  }

  return mask;

}


var maskimg;
//01 23 45 67
//00 11 22
function ledEffect() {
  
  let w = fsize;
  let h = canvas.height;

  var mask = generateMask(w, h, side, dots);
  
    /*
    let wid = fsize;
    var mask = ctx.createImageData(wid, canvas.height);
    var data = mask.data;
    for (let i = 0; i < data.length; i+=4) {
        let pix = i/4;
        let h = Math.floor(pix/wid);
        let w = pix%wid;
        //if (h%2 == 0) {
        //if (h%2 == 0 || w%2 == 0) {
        if (Math.floor(h/3)%2 == 0 || Math.floor(w/3)%2 == 0) {
            data[i]     = 30;     // red
            data[i + 1] = 30; // green
            data[i + 2] = 30; // blue
            data[i + 3] = 255;
        }
    }
    */
    
    /*
    //let gapL = 6 * fsize * 4;
    //let gapP = 6 * 4;
    for (let i = (4 * fsize + 4) * 4;i < data.length;i+=6 * fsize * 4) {
        
        let pix = i/4;
        let h = Math.floor(pix/wid);
        let w = pix%wid;
        
        for (let k = i;;k+=6 * 4) {
          let _pix = k/4;
          let _h = Math.floor(_pix/wid);
          let _w = _pix%wid;
          if (_h != h) break;
          data[k]     = 255;
          data[k + 1] = 0;
          data[k + 2] = 0;
          data[k + 3] = 255;
        }
    }
    */
        
    // create a temporary canvas
    var tempCanvas = document.createElement("canvas");
    var tempCtx = tempCanvas.getContext("2d");

    // set the temp canvas size == the canvas size
    tempCanvas.width = w;
    tempCanvas.height = canvas.height;

    // put the modified pixels on the temp canvas
    tempCtx.putImageData(mask, 0, 0);

    // use the tempCanvas.toDataURL to create an img object
    maskimg = new Image();
    //maskimg.onload = function() {}
    maskimg.src = tempCanvas.toDataURL();

}

var phase = 0;
var keepGoing = 1;

var pre = 0;
var particles = [];
var doblank = 0;

function react() {
  if (maskimg != null) {
    ledEffect();
  }
}

function keyboard(e) {

    switch (e.keyCode) {
        case 76: //'l'
            if (maskimg != null) {
              maskimg = null;
            } else {
              ledEffect();
            }
            break;
        case 66: //'b'
            doblank = doblank == 0?1:0;
            break;
        case 38: //'ArrowUp'
            speed += 20;
            break; 
        case 40: //'ArrowDown':
            speed -= 20;
            //if (speed < 10) speed = 0;
            break;
        case 37: //'ArrowLeft'
            break; 
        case 39: //'ArrowRight'
            break;
        case 48:    case 49:  case 50:  case 51:  case 52:  case 53:  case 54:  case 55:  case 56:  case 57: {
        //case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
            var value = e.keyCode - 48;
            if (value > subtitle.length - 1)
                break;
            if (value == 0) 
                keepGoing = 0;
            phase = value;
            initAnim();
        }
          break;
            
            
    }

}

init();

window.addEventListener('resize', doresize);
//window.addEventListener('click', initAnim, false);
//document.getElementsByTagName("canvas")[0].addEventListener("touchend", initAnim, false);
window.addEventListener('keyup', keyboard, false);

phase = 1;
initAnim();
ledEffect();

</script>
