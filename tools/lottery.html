<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>拈鬮Go</title>
    <style>
        :root {
            --bg1: #0b1020;
            --bg2: #121a33;
            --panel: #0f1730cc;
            --text: #eaf0ff;
            --muted: #a9b4da;
            --accent: #7aa2ff;
            --danger: #ff6b88;
            --line: #2a3a77;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", sans-serif;
            color: var(--text);
            background:
                radial-gradient(1200px 700px at 70% 10%, #1b2a66 0%, transparent 60%),
                radial-gradient(900px 600px at 20% 30%, #2a1b66 0%, transparent 55%),
                linear-gradient(180deg, var(--bg1), var(--bg2));
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .wrap {
            /* width:min(1100px, 100%); */
            width: 100%;
            display: grid;
            grid-template-columns: 1.2fr 0.8fr;
            gap: 18px;
        }

        .card {
            background: var(--panel);
            border: 1px solid #253066;
            border-radius: 16px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, .35);
            overflow: hidden;
        }

        .stage {
            padding: 14px;
        }

        .topbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 14px 14px 0 14px;
        }

        .title {
            font-size: 16px;
            font-weight: 850;
            letter-spacing: .3px;
        }

        .hint {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.35;
            margin-top: 2px;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            box-shadow: 0 0 0 4px rgba(122, 162, 255, .12);
        }

        .side {
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .section {
            padding: 12px;
            border: 1px solid #243064;
            border-radius: 14px;
            background: rgba(5, 10, 25, .35);
        }

        .section h3 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #dbe4ff;
        }

        textarea {
            width: 100%;
            height: 210px;
            resize: vertical;
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(2, 6, 18, .55);
            color: var(--text);
            padding: 10px;
            line-height: 1.45;
            outline: none;
        }

        textarea:focus {
            border-color: rgba(122, 162, 255, .9);
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        label {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="number"] {
            width: 92px;
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid var(--line);
            background: rgba(2, 6, 18, .55);
            color: var(--text);
            outline: none;
            font-weight: 750;
        }

        input[type="number"]:focus {
            border-color: rgba(122, 162, 255, .9);
        }

        button {
            appearance: none;
            border: 1px solid var(--line);
            background: rgba(122, 162, 255, .16);
            color: var(--text);
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 750;
            letter-spacing: .2px;
            transition: transform .05s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
            user-select: none;
        }

        button:hover {
            background: rgba(122, 162, 255, .22);
            border-color: #3e58b3;
        }

        button:active {
            transform: translateY(1px);
        }

        button.primary {
            background: rgba(122, 162, 255, .28);
            border-color: #5070e6;
        }

        button.danger {
            background: rgba(255, 107, 136, .16);
            border-color: #7a2a3e;
        }

        button:disabled {
            opacity: .55;
            cursor: not-allowed;
        }

        .winners {
            display: grid;
            gap: 8px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .winnerItem {
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid var(--line);
            background: rgba(122, 162, 255, .10);
            display: flex;
            justify-content: space-between;
            gap: 10px;
            min-height: 44px;
        }

        .winnerItem .rank {
            font-weight: 900;
            color: #dbe4ff;
            min-width: 60px;
        }

        .winnerItem .name {
            font-weight: 850;
            letter-spacing: .2px;
            flex: 1;
        }

        .winnerItem .meta {
            color: var(--muted);
            font-size: 12px;
            font-weight: 650;
            white-space: nowrap;
        }

        .footer-note {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.45;
        }

        @media (max-width: 980px) {
            .wrap {
                grid-template-columns: 1fr;
            }

            canvas {
                height: 480px;
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="card stage">
            <div class="topbar">
                <div>
                    <div class="title"></div>
                    <div class="hint"></div>
                </div>
                <div class="badge"><span class="dot"></span><span id="statusText"></span></div>
            </div>
            <div style="display: flex;justify-content: center;align-items: center;padding:14px;">
                <canvas id="canvas" width="500" height="700"></canvas>
            </div>
        </div>

        <div class="card side">
            <div class="section">
                <h3>名單</h3>
                <textarea id="inputArea">
張三, 李四, 王五, 趙六, 普T, 金胖, 三普, 老司機, 高市, 北市, 桃園 , 南市, 中市, 新北, 甲乙, 丙丁</textarea>
                <textarea id="listArea" hidden="true" readonly></textarea>
                <!-- <ol id="candidate" hidden="true"></ol> -->
                <div class="footer-note" style="margin-top:8px;">
                    <button class="primary" id="toParseBtn" onclick="parseNames()">輸入名單</button>
                    <button class="primary" id="toEditBtn" onclick="editNames()" hidden="true">編輯名單</button>
                </div>
            </div>

            <div class="section" id="control" hidden="true">
                <h3></h3>
                <div class="row">
                    <!--label>得獎人數
                        <input id="winnerCount" type="number" min="1" step="1" value="5" />
                    </label>
                    <label>出球間隔（秒）
                        <input id="dropInterval" type="number" min="0.8" step="0.1" value="2.0" />
                    </label-->
                    <button class="primary" id="btnStart" style="background-color: green;"
                        onclick="readyGo()">開始</button>
                    <button class="primary" id="btnEnd" style="background-color: red;" onclick="theEnd()"
                        hidden="true">結束</button>
                    <button class="primary" id="btnCatch" style="width:40%;background-color: white;color: black;"
                        hidden="true" onclick="openGate()">抽獎</button>
                    <!-- <button class="danger" onclick="clear()">清空名單</button> -->
                </div>
            </div>

            <div class="section">
                <h3>結果（依序掉出）</h3>
                <ol id="winnersList" class="winners"></ol>
            </div>
        </div>
    </div>
</body>

</html>
<script>

    function elmOff(_id) {
        document.getElementById(_id).hidden = true;
    }

    function elmOn(_id) {
        document.getElementById(_id).hidden = false;
    }

    function elmDisable(_id) {
        document.getElementById(_id).disabled = true;
    }

    function elmEnable(_id) {
        document.getElementById(_id).disabled = false;
    }

    function _mode(mode) {

        //<textarea id="inputArea">
        //<textarea id="listArea" hidden="true" readonly></textarea>
        //<button class="primary" id="toParseBtn" onclick="parseNames()">輸入名單</button>
        //<button class="primary" id="toEditBtn" onclick="editNames()" hidden="true">編輯名單</button>
        
        //<div class="section" id="control" hidden="true">
            //<button class="primary" id="btnStart" onclick="readyGo()">開始</button>
            //<button class="primary" id="btnEnd" onclick="theEnd()">結束</button>
            //<button class="primary" id="btnCatch" hidden="true" onclick="openGate()">抽獎</button>

        //<ol id="winnersList" class="winners"></ol>

        switch(mode) {
            case 'end_ready_mode':
            case 'edit_mode':
                elmOn('inputArea');
                elmOn('toParseBtn');
                elmOff('listArea');
                elmOff('toEditBtn');

                elmOff('control');                
                break;
            case 'editdone_mode':
                elmOff('inputArea');
                elmOff('toParseBtn');
                elmOn('listArea');
                elmOn('toEditBtn');
                elmEnable('toEditBtn');

                elmOn('control');
                    //elmOn('btnStart');
                    elmEnable('btnStart');
                    elmOff('btnEnd');
                    elmOff('btnCatch');
                break;
            case 'running_mode':
                //elmOn('btnStart');
                elmDisable('toEditBtn');
                elmDisable('btnStart');
                elmOn('btnEnd');
                elmOn('btnCatch');
                break;
            //case 'end_ready_mode': break;
        }
    }

    const winnersList = document.getElementById("winnersList");
    const listArea = document.getElementById("listArea");
    const inputArea = document.getElementById("inputArea");
    let all_list = [''];
    let winners_list = [];

    function setWinner(idx) {
        winners_list.push(idx + '. ' + all_list[idx]);
        winnersList.innerHTML = "";
        for (let k = winners_list.length - 1; k >= 0; k--) {
            const li = document.createElement("li");
            li.className = "winnerItem";
            li.innerHTML = winners_list[k];
            winnersList.appendChild(li);
        }
    }

    function theEnd() {
        stopRunning();
        //all_list = [''];
        //winners_list = [];
        _mode('editdone_mode');
        //editNames();
        //stopRunning();
    }

    function readyGo() {
        winnersList.innerHTML = "";
        winners_list = [];
        _mode('running_mode');
        setMembers(all_list);
        setTimeout(() => {
            start();
        }, 200);
    }

    function parseNames() {
        const raw = inputArea.value
            //.split(/\r?\n/)
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
        all_list = [''];
        let txt = '';
        for (let i = 0; i < raw.length; i++) {
            all_list[i + 1] = raw[i].trim();
        }
        for (let i = 1; i < all_list.length; i++) {
            txt += (i) + '. ' + all_list[i] + '\n';
        }
        listArea.value = txt;

        if (all_list.length > 0) 
            _mode('editdone_mode');

    }

    function editNames() {
        _mode('edit_mode');
    }

</script>
<script>
    var memberimgs = [];
    var members = [''];

    class Vector {

        x = 0;
        y = 0;

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        // Add another vector
        add(otherVector) {
            this.x += otherVector.x;
            this.y += otherVector.y;
            return this;
            //return new Vector(this.x + otherVector.x, this.y + otherVector.y);
        }

        // Subtract another vector
        sub(otherVector) {
            this.x -= otherVector.x;
            this.y -= otherVector.y;
            return this;
        }

        // Scale by a scalar value
        scale(scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        }

        getScaleV(scalar) {
            return new Vector(this.x * scalar, this.y * scalar);
        }

        // Calculate length (magnitude)
        getLength() {
            return Math.hypot(this.x, this.y);
        }

        // Normalize (get unit vector)
        getNormalize() {
            const len = this.getLength();
            if (len > 0) {
                return new Vector(this.x / len, this.y / len);
            }
            return new Vector(0, 0);
        }

        normalize() {
            const len = this.getLength();
            if (len > 0) {
                this.x /= len;
                this.y /= len;
            } else {
                this.x = 0;
                this.y = 0;
            }
            return this;
        }

        // Calculate dot product
        dot(otherVector) {
            return this.x * otherVector.x + this.y * otherVector.y;
        }

        getAngle() {
            return this.getAngleFromHeadPoiont(null);
        }

        getAngleFromHeadPoiont(t) {
            let v = t == null ? this : new Vector(t.x - this.x, t.y - this.y);
            let len = v.getLength();//sqrt(v.x * v.x + v.y * v.y);
            if (len < 0.001) len = 0.001;
            let cosvalue = v.x / len;//sqrt(v.x * v.x + v.y * v.y);
            //if (isnan(cosvalue))  return 0;
            if (cosvalue < -1) {
                cosvalue = -1;
            } else if (cosvalue > 1) {
                cosvalue = 1;
            }
            let d = R2D(Math.acos(cosvalue));
            if (v.y < 0) d = 360 - d;
            //log("%f : %f", d, R2D(v.angle(Vec2(1, 0), v)));
            return d;
        }
    }

    function D2R(degrees) {
        return degrees * (Math.PI / 180);
    }

    function R2D(radien) {
        return radien * (180 / Math.PI);
    }

    function getUnitVectorFromAngle(_angle) {
        let x = Math.cos(D2R(_angle));
        return new Vector(x, (_angle < 180 ? 1 : -1) * Math.sqrt(1 - x * x));
    }

    function convertPos(c, pos) {
        return [pos.x, c.height - pos.y];
    }

    function getAngleDiff(a1, a2) {

        let diff = Math.abs(a2 - a1);

        if (a1 < a2) {
            if (diff > 180) {
                return diff - 360;
            } else {
                return diff;
            }
        } else {
            if (diff > 180) {
                return 360 - diff;
            } else {
                return -diff;
            }
        }

    }

    function angleNormalized(_a) {
        if (_a < 0) {
            return _a + 360;
        } else if (_a >= 360) {
            return _a - 360;
        }
        return _a;
    }

    const radius = 20;

    function setMembers(mems) {
        members = mems;
    }

    class Ball {

        R = 0;
        G = 0;
        B = 0;

        pos = null;
        dir = null;
        name = '';
        action = 0;
        idx = -1;
        target = null;
        bscale = 1;

        initial(c, _idx) {

            this.idx = _idx;
            this.name = members[this.idx];

            this.pos = new Vector(c.width / 2, c.height / 2);
            //new Vector(c.width / 2 + c.width * (-0.4 + Math.random() * 0.8), c.height / 2 + c.height * (-0.4 + Math.random() * 0.8));
            this.dir = getUnitVectorFromAngle(Math.random() * 360).scale(c.width * (0.5 + 0.5 * Math.random()));// new Vector(0, 0);
        }
        draw(c, _ctx) {

            const img = memberimgs[this.idx];
            if (this.action == 0)
                _ctx.drawImage(img, this.pos.x - img.width / 2, this.pos.y - img.height / 2);
            else {
                _ctx.drawImage(img, this.pos.x - this.bscale * img.width / 2, this.pos.y - this.bscale * img.height / 2, this.bscale * img.width, this.bscale * img.height);
            }
        }

        wall(c, _dt) {

            const bounce = 1.0;

            if (this.pos.x < radius) { //left
                this.pos.x = radius + 1;
                let diff = getAngleDiff(this.dir.getScaleV(-1).getAngle(), 0);
                diff = 0 + diff;
                diff = angleNormalized(diff);
                let add = getUnitVectorFromAngle(diff).scale(bounce * this.dir.getLength());
                this.dir = add;
            } else if (this.pos.x > c.width - radius) { //right
                this.pos.x = c.width - radius - 1;
                let diff = getAngleDiff(this.dir.getScaleV(-1).getAngle(), 180);
                diff = 180 + diff;
                diff = angleNormalized(diff);
                let add = getUnitVectorFromAngle(diff).scale(bounce * this.dir.getLength());
                this.dir = add;
            }

            if (this.pos.y < radius) { //bottom
                this.pos.y = radius + 1;
                let diff = getAngleDiff(this.dir.getScaleV(-1).getAngle(), 90);
                diff = 90 + diff;
                diff = angleNormalized(diff);
                let add = getUnitVectorFromAngle(diff).scale((bounce - 0.1) * this.dir.getLength());
                //add.add(new Vector(c.width/2 - this.pos.x, 0 - this.pos.y).normalize().scale(c.width/2));
                this.dir = add;
                this.dir.add(new Vector(c.width / 2 - this.pos.x, 0 - this.pos.y).normalize().scale(2 * c.width).scale(_dt));

            } else if (this.pos.y > c.height - radius) { //top
                this.pos.y = c.height - radius - 1;
                let diff = getAngleDiff(this.dir.getScaleV(-1).getAngle(), 270);
                diff = 270 + diff;
                diff = angleNormalized(diff);
                let add = getUnitVectorFromAngle(diff).scale(bounce * this.dir.getLength());
                this.dir = add;
            }
        }

        gravity(c, _dt) {
            let gv = getUnitVectorFromAngle(270).scale(c.height * 0.5).scale(_dt);
            this.dir.add(gv);
        }

        wind(c, _dt) {

            if (!dofan) return;

            {
                let wv = new Vector(this.pos.x - c.width / 2, this.pos.y - 0);
                let diff = getAngleDiff(90, wv.getAngle());
                if (Math.abs(diff) < 45) {
                    let weight = (100 - Math.abs(diff)) / 90.0;//Math.pow((100 - Math.abs(diff))/90.0, 2);
                    wv.normalize().scale(2 * (c.height - this.pos.y) * weight);
                    this.dir.add(wv.scale(_dt));
                }

            }


            {
                let wv = new Vector(this.pos.x - 0, this.pos.y - 0);
                let diff = getAngleDiff(45, wv.getAngle());
                if (wv.getLength() < c.width) {
                    //let weight = (90 - Math.abs(diff)) / 90.0;//Math.pow((100 - Math.abs(diff))/90.0, 2);
                    let weight2 = c.width - wv.getLength();
                    wv = getUnitVectorFromAngle(45).scale(2.0 * weight2);
                    //wv.normalize().scale(2.0 * weight2);
                    this.dir.add(wv.scale(_dt));
                }
            }

            {
                let wv = new Vector(this.pos.x - 0, this.pos.y - c.height);
                let diff = getAngleDiff(315, wv.getAngle());
                if (wv.getLength() < c.width) {
                    //let weight = (90 - Math.abs(diff)) / 90.0;//Math.pow((100 - Math.abs(diff))/90.0, 2);
                    let weight2 = c.width - wv.getLength();
                    wv = getUnitVectorFromAngle(315).scale(2.0 * weight2);
                    //wv.normalize().scale(2.0 * weight2);
                    this.dir.add(wv.scale(_dt));
                }
            }

            {
                let wv = new Vector(this.pos.x - c.width, this.pos.y - c.height);
                let diff = getAngleDiff(225, wv.getAngle());
                if (wv.getLength() < c.width) {
                    //let weight = (90 - Math.abs(diff)) / 90.0;//Math.pow((100 - Math.abs(diff))/90.0, 2);
                    let weight2 = c.width - wv.getLength();
                    wv = getUnitVectorFromAngle(225).scale(2.0 * weight2);
                    //wv.normalize().scale(2.0 * weight2);
                    this.dir.add(wv.scale(_dt));
                }
            }

            {
                let wv = new Vector(this.pos.x - c.width, this.pos.y - 0);
                let diff = getAngleDiff(135, wv.getAngle());
                if (wv.getLength() < c.width) {
                    //let weight = (90 - Math.abs(diff)) / 90.0;//Math.pow((100 - Math.abs(diff))/90.0, 2);
                    let weight2 = c.width - wv.getLength();
                    wv = getUnitVectorFromAngle(135).scale(2.0 * weight2);
                    //wv.normalize().scale(2.0 * weight2);
                    this.dir.add(wv.scale(_dt));
                }
            }

        }

        update(c, _ctx, dt) {

            let _dt = dt / 1000.0;

            switch (this.action) {
                case 0:

                    this.wind(c, _dt);
                    this.gravity(c, _dt);
                    this.wall(c, _dt);

                    if (this.dir.getLength() > c.height * 1.2)
                        this.dir.normalize().scale(c.height);

                    this.pos.add(this.dir.getScaleV(_dt));

                    break;
                case 1:
                    if (this.target == null) break;
                    this.pos.x += (this.target.x - this.pos.x) * _dt;
                    this.pos.y += (this.target.y - this.pos.y) * _dt;
                    this.bscale += (1.8 - this.bscale) * _dt * 4;
                    break;
            }

            this.draw(c, _ctx);

        }

    }

    var canvas;
    var ctx;
    var pre = 0;
    var keepGoing = false;
    var particles = [];
    var dofan = false;
    var gate = 0;

    function stopRunning() {
        keepGoing = false;
        gate = 0;
        particles = [];
        memberimgs = [];
        members = [];
        setTimeout(function () {
            init();
        }, 500);
    }
    function start() {
        gate = 0;
        keepGoing = false;
        dofan = false
        initAnim();
        setTimeout(function () {
            openFan();
        }, 3000);
    }
    function openFan() {
        dofan = true;
    }

    function closeFan() {
        dofan = false;
    }

    function init() {

        canvas = document.getElementById("canvas");
        //canvas.width = window.innerWidth;
        //canvas.height = window.innerHeight;
        ctx = canvas.getContext("2d");

        ctx.font = "24px Monospace";
        ctx.textAlign = "center";

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        //ctx.fillStyle = 'red';
        //ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'white';
        ctx.fillText('拈鬮Go', canvas.width / 2, canvas.height / 2);

        drawBox();

    }

    function drawBox() {

        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
        //ctx.fillRect(10, 50, 50, 40);
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(0, 0, canvas.width, canvas.height, 10);
        ctx.stroke();
        ctx.closePath();

    }

    var hole_pos = new Vector(0, 0);
    var hole_target_pos = new Vector(0, 0);

    function openGate() {
        //if (gate > 0) return;
        if (gate == 1) return;
        if (gate == 3) return;
        
        //if (gate == 2) {}

        gate = 1;
        prepareGate();
        setTimeout(function () {
            startUsingGate();
        }, 2000);
    }

    function prepareGate() {
        hole_target_pos.x = canvas.width * (0.2 + Math.random() * 0.6);
        hole_target_pos.y = canvas.height * (0.3 + Math.random() * 0.4);
    }

    function startUsingGate() {
        gate = 2;
    }

    function drawHole(dt) {
        switch (gate) {
            case 0: //nothing
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                break;
            case 1: //ready
                ctx.fillStyle = 'rgba(200, 0, 0, 0.5)';//'rgba(255, 255, 255, 0.5)';
                break;
            case 2: //search
                if (Math.random() > 0.5)
                    ctx.fillStyle = 'rgba(0, 255, 0, 1.0)';
                else
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                break;
            case 3:
                ctx.fillStyle = 'rgba(200, 0, 0, 0.5)';
                break;
        }

        hole_pos.x = hole_pos.x + (hole_target_pos.x - hole_pos.x) * 2 * dt / 1000.0;
        hole_pos.y = hole_pos.y + (hole_target_pos.y - hole_pos.y) * 2 * dt / 1000.0;

        ctx.fillRect(hole_pos.x - 5, canvas.height, 10, -(canvas.height - hole_pos.y - 2 * radius));
        //ctx.fillRect(0, hole_pos.y - 5, canvas.width, 10);

        //ctx.fillStyle = 'rgba(' + this.R + ',' + this.G + ',' + this.B + ', 1.0)';
        ctx.beginPath();
        ctx.arc(hole_pos.x, hole_pos.y, radius * 2, 0, 2 * Math.PI, true);
        ctx.fill();
        ctx.closePath();

        if (gate == 2) {
            let mini = -1;
            let minirange = -1;
            for (let i = 1; i < particles.length; i++) {
                if (particles[i].action != 0) continue;
                let _v = new Vector(hole_target_pos.x - particles[i].pos.x, hole_target_pos.y - particles[i].pos.y);
                let len = _v.getLength();
                if (minirange < 0 || len < minirange) {
                    minirange = len;
                    mini = i;
                }
                if (len < radius * 4) { //有碰到
                    particles[i].dir.add(_v.normalize().scale(radius * 3 * dt / 1000.0));
                }

            }
            if (mini == -1) {
                gate = 0;
                return;
            }
            if (minirange < radius / 1.5) {
                gate = 3;
                particles[mini].action = 1;
                particles[mini].target = new Vector(hole_target_pos.x, hole_target_pos.y);
                setTimeout(() => {
                    particles[mini].target = new Vector(hole_target_pos.x, canvas.height * 2);
                }, 2000);
                setTimeout(() => {
                    setWinner(mini);
                    gate = 0;
                }, 3000);
                return;
            }

            return;
        }

        if (gate == 3) {
            for (let i = 1; i < particles.length; i++) {
                if (particles[i] != null && particles[i].action == 1) {
                    particles[i].draw(canvas, ctx);
                }
            }
        }

    }

    function anim_update(elapse) {

        let dt = elapse - pre;
        if (dt > 500) dt = 16.0;
        pre = elapse;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        //ctx.fillStyle = 'gray';
        //ctx.fillRect(0, 0, canvas.width, canvas.height);

        //ctx.scale(1, -1);        
        //ctx.translate(0, -canvas.height);
        //console.log(ctx.getTransform());
        //let _scale = 0.5;

        const gap = 30;

        ctx.transform(
            (canvas.width - gap * 2) / canvas.width,
            0,
            0,
            -(canvas.height - gap * 2) / canvas.height,
            gap,
            canvas.height - gap
        );

        //ctx.fillStyle = 'gray';
        //ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawHole(dt);

        drawBox();
        for (let i = 1; i < particles.length; i++) {
            particles[i].update(canvas, ctx, dt);
        }

        if (gate == 3) {
            drawHole(dt);
        }

        ctx.resetTransform();

        if (keepGoing)
            window.requestAnimationFrame(anim_update);

    }

    function initAnim() {

        //alert('initAnim');

        hole_pos = new Vector(canvas.width / 2, canvas.height / 2);
        hole_target_pos = new Vector(canvas.width / 2, canvas.height / 2);

        for (let i = 1; i < members.length; i++) {
            let img = generateBall('' + i);
            memberimgs[i] = img;
        }


        for (let i = 1; i < members.length; i++) {
            particles[i] = new Ball();
            particles[i].initial(canvas, i);
        }

        //if (idx > 0) window.requestAnimationFrame(anim_update);

        if (!keepGoing) {
            keepGoing = true;
            window.requestAnimationFrame(anim_update);
        }

    }

    function generateBall(txt) {

        const fsize = 20;

        const img_scale = 1.1;
        //txt = txt.substring(0, 1);

        let _font = fsize + "px Arial";
        var tempCanvas = document.createElement("canvas");
        var tempCtx = tempCanvas.getContext("2d");

        tempCtx.font = _font;
        tempCtx.textBaseline = 'middle';
        //let fw = radius * 2;//Math.ceil(tempCtx.measureText(txt).width) + 4;
        //let fh = radius * 2;//fontsize * 1.2;

        // set the temp canvas size == the canvas size
        tempCanvas.width = img_scale * radius * 2;
        tempCanvas.height = img_scale * radius * 2;


        //tempCtx = tempCanvas.getContext("2d");
        tempCtx.font = _font;

        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);


        tempCtx.transform(
            1,
            0,
            0,
            -1,
            0,
            tempCanvas.height
        );

        let r = Math.floor(Math.random() * 10);
        switch (r) {
            case 0:
                tempCtx.fillStyle = 'rgba(100,100,100, 1.0)';
                break;
            case 1:
                tempCtx.fillStyle = 'rgba(255,0,0, 1.0)';
                break;
            case 2:
                tempCtx.fillStyle = 'rgba(0,180,0, 1.0)';
                break;
            case 3:
                tempCtx.fillStyle = 'rgba(0,0,255, 1.0)';
                break;
            case 4:
                tempCtx.fillStyle = 'rgba(150,150,0, 1.0)';
                break;
            case 5:
                tempCtx.fillStyle = 'rgba(0,150,150, 1.0)';
                break;
            case 6:
                tempCtx.fillStyle = 'rgba(180,0,180, 1.0)';
                break;
            case 7:
                tempCtx.fillStyle = 'rgba(80,180,50, 1.0)';
                break;
            case 8:
                tempCtx.fillStyle = 'rgba(200,100,50, 1.0)';
                break;
            case 9:
                tempCtx.fillStyle = 'rgba(50,100,200, 1.0)';
                break;
        }

        tempCtx.strokeStyle = 'rgba(255, 255, 255, 1.0)';
        tempCtx.lineWidth = 2;

        tempCtx.beginPath();
        tempCtx.arc(tempCanvas.width / 2, tempCanvas.height / 2, img_scale * radius - 1, 0, 2 * Math.PI, true);
        tempCtx.fill();
        tempCtx.closePath();

        tempCtx.beginPath();
        tempCtx.arc(tempCanvas.width / 2, tempCanvas.height / 2, img_scale * radius - 2, 0, 2 * Math.PI, true);
        tempCtx.stroke();
        tempCtx.closePath();

        tempCtx.textAlign = "center";

        tempCtx.fillStyle = 'rgba(255,255,255, 1.0)';
        //tempCtx.strokeText(txt, tempCanvas.width / 2, tempCanvas.height / 2); // + '('+ _s +','+ _d +')'
        tempCtx.fillText(txt, tempCanvas.width / 2, tempCanvas.height / 2 + fsize / 3);

        tempCtx.resetTransform();

        const dataURL = tempCanvas.toDataURL(); // Creates a PNG image data URL by default
        // Create a new Image object and set its source to the data URL
        const img = new Image();

        img.src = dataURL;
        return img;

    }

    init();

</script>