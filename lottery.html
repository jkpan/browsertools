<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>lottery</title>
    <style>
        body {
            margin: 0;

            /* min-height: 100vh; */
            /* display: flex; */
            align-items: center;
            justify-content: center;
            padding: 10px;
            background-color: rgb(100, 100, 100);
        }

        .container {
            display: flex;
            align-items: center;
            align-content: center;
            /* 垂直置中 */
            /* justify-content: center;  // 可選：水平置中 */
            height: 100%;
            width: 100%;
            /* 容器需要有高度 */
            border: 1px solid black;
        }
    </style>
</head>

<body>

    <div class="container">
        <canvas width="400" height="600" id="canvas" aria-label="大樂透開獎動畫畫布"></canvas>
    </div>
    <button onclick="start()">Start</button>
    <button onclick="stop()">Stop</button>
    <!-- <button onclick="start()">Open</button> -->


</body>

</html>
<script type="text/javascript" charset="UTF-8">

    var members = [
        '1. James'
    ];

    class Vector {

        x = 0;
        y = 0;

        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        // Add another vector
        add(otherVector) {
            this.x += otherVector.x;
            this.y += otherVector.y;
            //return new Vector(this.x + otherVector.x, this.y + otherVector.y);
        }

        // Subtract another vector
        sub(otherVector) {
            this.x -= otherVector.x;
            this.y -= otherVector.y;
        }

        // Scale by a scalar value
        scale(scalar) {
            this.x *= scalar;
            this.y *= scalar;
        }

        getScaleV(scalar) {
            return new Vector(this.x * scalar, this.y * scalar);
        }

        // Calculate length (magnitude)
        getLength() {
            return Math.hypot(this.x, this.y);
        }

        // Normalize (get unit vector)
        getNormalize() {
            const len = this.getLength();
            if (len > 0) {
                return new Vector(this.x / len, this.y / len);
            }
            return new Vector(0, 0);
        }

        normalize() {
            const len = this.getLength();
            if (length > 0) {
                this.x /= len;
                this.y /= len;
            } else {
                this.x = 0;
                this.y = 0;
            }
        }

        // Calculate dot product
        dot(otherVector) {
            return this.x * otherVector.x + this.y * otherVector.y;
        }

        getAngle() {
            return this.getAngleFromHeadPoiont(null);
        }

        getAngleFromHeadPoiont(t) {
            let v = t == null? this: new Vector(t.x - this.x, t.y - this.y);
            let len = v.getLength();//sqrt(v.x * v.x + v.y * v.y);
            if (len < 0.001) len = 0.001;
            let cosvalue = v.x / len;//sqrt(v.x * v.x + v.y * v.y);
            //if (isnan(cosvalue))  return 0;
            if (cosvalue < -1) {
                cosvalue = -1;
            } else if (cosvalue > 1) {
                cosvalue = 1;
            }
            let d = R2D(Math.acos(cosvalue));
            if (v.y < 0) d = 360 - d;
            //log("%f : %f", d, R2D(v.angle(Vec2(1, 0), v)));
            return d;
        }
    }

    function D2R(degrees) {
        return degrees * (Math.PI / 180);
    }

    function R2D(radien) {
        return radien * (180 / Math.PI);
    }

    function getUnitVectorFromAngle(_angle) {
        let x = Math.cos(D2R(_angle));
        return new Vector(x, (_angle < 180 ? 1 : -1) * Math.sqrt(1 - x * x));
    }

    function convertPos(c, pos) {
        return [pos.x, c.height - pos.y];
    }

    function getAngleDiff(a1, a2) {

        let diff = Math.abs(a2 - a1);

        if (a1 < a2) {
            if (diff > 180) {
                //diff = 360 - diff;
                //return -diff;
                return diff - 360;
            } else {
                return diff;
            }
        } else {
            if (diff > 180) {
                //diff = 360 - diff;
                //return diff;
                return 360 - diff;
            } else {
                return -diff;
            }
        }

    }

    function angleNormalized(_a) {
        if (_a < 0) {
            return _a + 360;
        } else if (_a >= 360) {
            return _a - 360;
        }
        return _a;
    }

    class Ball {

        R = 0;
        G = 0;
        B = 0;

        pos = null;
        dir = null;
        //angle = 90;
        //vector = null;
        name = '';

        radius = 20;

        //t: 0,
        //elapse: 0,
        //idx: 0,

        initial(c, _name) {

            this.name = _name;

            this.pos = new Vector(c.width/2 + c.width * (-0.1 + Math.random() * 0.2), 
                                  c.height/2 + c.height * (-0.1 + Math.random() * 0.2));
            this.dir = new Vector(0, 0);

            this.idx = Math.floor(Math.random() * 6);
            this.colorDis(this.idx);

        }

        colorDis(idx) {
            let r0 = 100 * Math.random();
            let r1 = 100 * Math.random();
            let rc0 = 255;// + 55 * Math.random();
            let rc1 = 255;// + 55 * Math.random();
            switch (idx) {
                case 0: this.R = rc0; this.G = r0; this.B = r1; break;
                case 1: this.R = r0; this.G = rc0; this.B = r1; break;
                case 2: this.R = r0; this.G = r1; this.B = rc0; break;
                case 3: this.R = r0; this.G = rc0; this.B = rc1; break;
                case 4: this.R = rc0; this.G = r0; this.B = rc1; break;
                case 5: this.R = rc0; this.G = rc1; this.B = r0; break;
            }
        }

        draw(c, _ctx) {
            _ctx.fillStyle = 'rgba(' + this.R + ',' + this.G + ',' + this.B + ', 1.0)';
            _ctx.beginPath();

            let r = (c.width, c.height) / 2 * 0.005;
            _ctx.arc(this.pos.x, this.pos.y, this.radius, 0, 2 * Math.PI, true);

            _ctx.fill();
            _ctx.closePath();

        }

        wall(c, _dt) {
            
            if (this.pos.x < this.radius - 1) { //left
                this.pos.x = this.radius + 2;
                let diff = getAngleDiff(this.dir.getScaleV(-1).getAngle(), 0);
                diff = 0 + diff;
                diff = angleNormalized(diff);
                let add = getUnitVectorFromAngle(diff);
                add.scale(this.dir.getLength());
                this.dir = add;
            } else if (this.pos.x > c.width - this.radius) { //right
                
            }

            if (this.pos.y < this.radius) { //bottom
                
            } else if (this.pos.y > c.height - this.radius) { //top
                
            }
        }

        gravity(c, _dt) {
            let gv = getUnitVectorFromAngle(270);
            gv.scale(c.height * 0.2);
            this.dir.add(gv.getScaleV(_dt));
        }

        wind(c, _dt) {
            let w_start = new Vector(c.width/2, 0);
            let w_v = new Vector(this.pos.x - w_start.x, this.pos.y - w_start.y);
            let diff = getAngleDiff(90, w_v.getAngle());
            let wv = w_v.getNormalize().getScaleV((c.height - this.pos.y) * (100 - Math.abs(diff))/90.0);
            this.dir.add(wv.getScaleV(_dt));
        }

        update(c, _ctx, dt) {

            let _dt = dt / 1000.0;


            this.wall(c, _dt);
            this.gravity(c, _dt);
            this.wind(c, _dt);
            
            this.pos.add(this.dir.getScaleV(_dt));//this.vector.getScaleV(_dt));

            this.draw(c, _ctx);

            /*
            _ctx.fillRect(_target[0] - 5, _target[1] - 5, 10, 10);
            _ctx.font = "20px Monospace";
            _ctx.fillText('' + this.angle , 10, c.height/2);
            _ctx.fillText('' + ta , 10, c.height/2 + 20);
            _ctx.fillText('' + diff , 10, c.height/2 + 40);
            */

            //pre.sub(this.pos);

        }

    }

    var canvas;
    var ctx;
    var pre = 0;
    var keepGoing = false;
    var particles = [];

    function stop() {
        keepGoing = false;
    }
    function start() {
        stop();
        setTimeout(function () {
            initAnim();
        }, 1000);
    }

    function init() {

        canvas = document.getElementById("canvas");
        //canvas.width = window.innerWidth;
        //canvas.height = window.innerHeight;
        ctx = canvas.getContext("2d");

    }

    function drawBox() {

        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
        //ctx.fillRect(10, 50, 50, 40);
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.roundRect(0, 0, canvas.width, canvas.height, 10);
        ctx.stroke();
        ctx.closePath();

        //ctx.roundRect(0, 0, canvas.width, canvas.height, 8);

        //ctx.strokeRect(0, 0, canvas.width, canvas.height);

        //ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        //ctx.scale(1, -1);
        //ctx.fillText('5' , 15, 25);

    }

    function anim_update(elapse) {

        let dt = elapse - pre;
        if (dt > 1000) dt = 16.0;
        pre = elapse;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = 'green';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        //ctx.scale(1, -1);        
        //ctx.translate(0, -canvas.height);
        //console.log(ctx.getTransform());

        //let _scale = 0.5;
        const gap = 10;

        ctx.transform(
            (canvas.width - gap * 2) / canvas.width,
            0,
            0,
            -(canvas.height - gap * 2) / canvas.height,
            gap,
            canvas.height - gap
        );

        //ctx.fillStyle = 'gray';
        //ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawBox();
        for (var i = 0; i < particles.length; i++) {
            particles[i].update(canvas, ctx, dt);
        }
        ctx.resetTransform();


        

        //console.log(dt);

        
        
        

        if (keepGoing)
            window.requestAnimationFrame(anim_update);

    }

    function initAnim() {


        for (var i = 0; i < members.length; i++) {
            particles[i] = new Ball();
            particles[i].initial(canvas, members[i]);
        }


        //if (idx > 0) window.requestAnimationFrame(anim_update);

        if (!keepGoing) {
            keepGoing = true;
            window.requestAnimationFrame(anim_update);
        }

    }

    init();
    
    //initAnim();

    /*
    window.onload = function () {
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        var img = document.getElementById("scream");
        ctx.drawImage(img, 10, 10);
    };
    */


</script>